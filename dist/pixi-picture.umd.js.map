{"version":3,"file":"pixi-picture.umd.js","sources":["../src/BlendFilter.ts","../src/MaskFilter.ts","../src/ShaderParts.ts","../src/FilterSystemMixin.ts","../src/index.ts"],"sourcesContent":["import {Filter} from '@pixi/core';\r\n\r\nexport class BackdropFilter extends Filter {\r\n    backdropUniformName: string = null;\r\n    _backdropActive: boolean = false;\r\n    clearColor: Float32Array = null;\r\n}\r\n\r\nexport interface IBlendShaderParts {\r\n    uniformCode?: string;\r\n    uniforms?: { [key: string]: any };\r\n    blendCode: string;\r\n}\r\n\r\nconst filterFrag = `\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\nuniform sampler2D uBackdrop;\r\n\r\n%UNIFORM_CODE%\r\n\r\nvoid main(void)\r\n{\r\n   vec4 b_src = texture2D(uSampler, vTextureCoord);\r\n   vec4 b_dest = texture2D(uBackdrop, vTextureCoord);\r\n   vec4 b_res = b_dest;\r\n   \r\n   %BLEND_CODE%\r\n\r\n   gl_FragColor = b_res;\r\n}`;\r\n\r\nexport class BlendFilter extends BackdropFilter {\r\n    constructor(shaderParts: IBlendShaderParts) {\r\n        let fragCode = filterFrag;\r\n        fragCode = fragCode.replace('%UNIFORM_CODE%', shaderParts.uniformCode || \"\");\r\n        fragCode = fragCode.replace('%BLEND_CODE%', shaderParts.blendCode || \"\");\r\n\r\n        super(undefined, fragCode, shaderParts.uniforms);\r\n\r\n        this.backdropUniformName = 'uBackdrop';\r\n    }\r\n}","import {FilterSystem, RenderTexture, Filter} from '@pixi/core';\r\nimport {BLEND_MODES, CLEAR_MODES} from '@pixi/constants';\r\nimport {BlendFilter} from \"./BlendFilter\";\r\n\r\nexport enum MASK_CHANNEL {\r\n    RED = 0,\r\n    GREEN,\r\n    BLUE,\r\n    ALPHA\r\n}\r\n\r\nexport class MaskConfig {\r\n    constructor(public maskBefore = false, channel: MASK_CHANNEL = MASK_CHANNEL.ALPHA) {\r\n        this.uniforms.uChannel[channel] = 1.0;\r\n    }\r\n    uniformCode = 'uniform vec4 uChannel;';\r\n    uniforms: any = {\r\n        uChannel: new Float32Array([0, 0, 0, 0]), // shared uniform for all those shaders? ok, just set it before apply\r\n    };\r\n    blendCode = `b_res = dot(b_src, uChannel) * b_dest;`;\r\n}\r\n\r\nexport class MaskFilter extends BlendFilter {\r\n    constructor(public baseFilter: Filter, public config = new MaskConfig()) {\r\n        super(config);\r\n        this.padding = baseFilter.padding;\r\n    }\r\n\r\n    apply(filterManager: FilterSystem, input: RenderTexture, output: RenderTexture,\r\n          clearMode: CLEAR_MODES) {\r\n        const target = filterManager.getFilterTexture(input);\r\n        if (this.config.maskBefore) {\r\n            const {blendMode} = this.state;\r\n            this.state.blendMode = BLEND_MODES.NONE;\r\n            filterManager.applyFilter(this, input, target, CLEAR_MODES.YES);\r\n            this.baseFilter.blendMode = blendMode;\r\n            this.baseFilter.apply(filterManager, target, output, clearMode);\r\n            this.state.blendMode = blendMode;\r\n        } else {\r\n            const {uBackdrop} = this.uniforms;\r\n            this.baseFilter.apply(filterManager, uBackdrop, target, CLEAR_MODES.YES);\r\n            this.uniforms.uBackdrop = target;\r\n            filterManager.applyFilter(this, input, output, clearMode);\r\n            this.uniforms.uBackdrop = uBackdrop;\r\n        }\r\n        filterManager.returnFilterTexture(target);\r\n    }\r\n}\r\n","import {BlendFilter} from \"./BlendFilter\";\r\nimport {BLEND_MODES} from \"@pixi/constants\";\r\n\r\nexport const NPM_BLEND =\r\n    `if (b_src.a == 0.0) {\r\ngl_FragColor = vec4(0, 0, 0, 0);\r\nreturn;\r\n}\r\nvec3 Cb = b_src.rgb / b_src.a, Cs;\r\nif (b_dest.a > 0.0) {\r\nCs = b_dest.rgb / b_dest.a;\r\n}\r\n%NPM_BLEND%\r\nb_res.a = b_src.a + b_dest.a * (1.0-b_src.a);\r\nb_res.rgb = (1.0 - b_src.a) * Cs + b_src.a * B;\r\nb_res.rgb *= b_res.a;\r\n`;\r\n\r\n//reverse hardlight\r\nexport const OVERLAY_PART =\r\n    `vec3 multiply = Cb * Cs * 2.0;\r\nvec3 Cb2 = Cb * 2.0 - 1.0;\r\nvec3 screen = Cb2 + Cs - Cb2 * Cs;\r\nvec3 B;\r\nif (Cs.r <= 0.5) {\r\nB.r = multiply.r;\r\n} else {\r\nB.r = screen.r;\r\n}\r\nif (Cs.g <= 0.5) {\r\nB.g = multiply.g;\r\n} else {\r\nB.g = screen.g;\r\n}\r\nif (Cs.b <= 0.5) {\r\nB.b = multiply.b;\r\n} else {\r\nB.b = screen.b;\r\n}\r\n`;\r\n\r\nexport const HARDLIGHT_PART =\r\n    `vec3 multiply = Cb * Cs * 2.0;\r\nvec3 Cs2 = Cs * 2.0 - 1.0;\r\nvec3 screen = Cb + Cs2 - Cb * Cs2;\r\nvec3 B;\r\nif (Cb.r <= 0.5) {\r\nB.r = multiply.r;\r\n} else {\r\nB.r = screen.r;\r\n}\r\nif (Cb.g <= 0.5) {\r\nB.g = multiply.g;\r\n} else {\r\nB.g = screen.g;\r\n}\r\nif (Cb.b <= 0.5) {\r\nB.b = multiply.b;\r\n} else {\r\nB.b = screen.b;\r\n}\r\n`;\r\n\r\nexport const SOFTLIGHT_PART =\r\n    `vec3 first = Cb - (1.0 - 2.0 * Cs) * Cb * (1.0 - Cb);\r\nvec3 B;\r\nvec3 D;\r\nif (Cs.r <= 0.5)\r\n{\r\nB.r = first.r;\r\n}\r\nelse\r\n{\r\nif (Cb.r <= 0.25)\r\n{\r\nD.r = ((16.0 * Cb.r - 12.0) * Cb.r + 4.0) * Cb.r;    \r\n}\r\nelse\r\n{\r\nD.r = sqrt(Cb.r);\r\n}\r\nB.r = Cb.r + (2.0 * Cs.r - 1.0) * (D.r - Cb.r);\r\n}\r\nif (Cs.g <= 0.5)\r\n{\r\nB.g = first.g;\r\n}\r\nelse\r\n{\r\nif (Cb.g <= 0.25)\r\n{\r\nD.g = ((16.0 * Cb.g - 12.0) * Cb.g + 4.0) * Cb.g;    \r\n}\r\nelse\r\n{\r\nD.g = sqrt(Cb.g);\r\n}\r\nB.g = Cb.g + (2.0 * Cs.g - 1.0) * (D.g - Cb.g);\r\n}\r\nif (Cs.b <= 0.5)\r\n{\r\nB.b = first.b;\r\n}\r\nelse\r\n{\r\nif (Cb.b <= 0.25)\r\n{\r\nD.b = ((16.0 * Cb.b - 12.0) * Cb.b + 4.0) * Cb.b;    \r\n}\r\nelse\r\n{\r\nD.b = sqrt(Cb.b);\r\n}\r\nB.b = Cb.b + (2.0 * Cs.b - 1.0) * (D.b - Cb.b);\r\n}\r\n`;\r\n\r\nexport const MULTIPLY_FULL =\r\n    `if (dest.a > 0.0) {\r\nb_res.rgb = (dest.rgb / dest.a) * ((1.0 - src.a) + src.rgb);\r\nb_res.a = min(src.a + dest.a - src.a * dest.a, 1.0);\r\nb_res.rgb *= mult.a;\r\n}\r\n`;\r\nexport const OVERLAY_FULL = NPM_BLEND.replace(`%NPM_BLEND%`, OVERLAY_PART);\r\nexport const HARDLIGHT_FULL = NPM_BLEND.replace(`%NPM_BLEND%`, HARDLIGHT_PART);\r\nexport const SOFTLIGHT_FULL = NPM_BLEND.replace(`%NPM_BLEND%`, SOFTLIGHT_PART);\r\n\r\nexport const blendFullArray: Array<string> = [];\r\n\r\nblendFullArray[BLEND_MODES.MULTIPLY] = MULTIPLY_FULL;\r\nblendFullArray[BLEND_MODES.OVERLAY] = OVERLAY_FULL;\r\nblendFullArray[BLEND_MODES.HARD_LIGHT] = HARDLIGHT_FULL;\r\nblendFullArray[BLEND_MODES.SOFT_LIGHT] = SOFTLIGHT_FULL;\r\n\r\nlet filterCache: Array<BlendFilter> = [];\r\nlet filterCacheArray: Array<Array<BlendFilter>> = [];\r\n\r\nexport function getBlendFilter(blendMode: BLEND_MODES) {\r\n    if (!blendFullArray[blendMode]) {\r\n        return null;\r\n    }\r\n    if (!filterCache[blendMode]) {\r\n        filterCache[blendMode] = new BlendFilter({blendCode: blendFullArray[blendMode]});\r\n    }\r\n    return filterCache[blendMode];\r\n}\r\n\r\nexport function getBlendFilterArray(blendMode: BLEND_MODES) {\r\n    if (!blendFullArray[blendMode]) {\r\n        return null;\r\n    }\r\n    if (!filterCacheArray[blendMode]) {\r\n        filterCacheArray[blendMode] = [getBlendFilter(blendMode)];\r\n    }\r\n    return filterCacheArray[blendMode];\r\n}","import {TextureSystem, FilterSystem, BaseTexture, RenderTexture, Filter, FilterState} from '@pixi/core';\r\nimport {CLEAR_MODES} from '@pixi/constants';\r\nimport {Matrix, Rectangle} from '@pixi/math';\r\nimport {DisplayObject} from '@pixi/display';\r\nimport {BackdropFilter} from \"./BlendFilter\";\r\n\r\nexport interface IPictureFilterSystem extends FilterSystem {\r\n    prepareBackdrop(sourceFrame: Rectangle): RenderTexture;\r\n\r\n    pushWithCheck(target: DisplayObject, filters: Array<Filter>, checkEmptyBounds?: boolean): boolean;\r\n}\r\n\r\nexport interface IPictureTextureSystem extends TextureSystem {\r\n    bindForceLocation(texture: BaseTexture, location: number): void;\r\n}\r\n\r\nfunction containsRect(rectOut: Rectangle, rectIn: Rectangle): boolean {\r\n    let r1 = rectIn.x + rectIn.width;\r\n    let b1 = rectIn.y + rectIn.height;\r\n    let r2 = rectOut.x + rectOut.width;\r\n    let b2 = rectOut.y + rectOut.height;\r\n    return (rectIn.x >= rectOut.x) &&\r\n        (rectIn.x <= r2) &&\r\n        (rectIn.y >= rectOut.y) &&\r\n        (rectIn.y <= b2) &&\r\n        (r1 >= rectOut.x) &&\r\n        (r1 <= r2) &&\r\n        (b1 >= rectOut.y) &&\r\n        (b1 <= b2);\r\n}\r\n\r\nfunction bindForceLocation(this: IPictureTextureSystem, texture: BaseTexture, location = 0) {\r\n    const { gl } = this;\r\n    if (this.currentLocation !== location)\r\n    {\r\n        this.currentLocation = location;\r\n        gl.activeTexture(gl.TEXTURE0 + location);\r\n    }\r\n    this.bind(texture, location);\r\n}\r\n\r\nconst tempMatrix = new Matrix();\r\n\r\nfunction pushWithCheck(this: IPictureFilterSystem,\r\n              target: DisplayObject, filters: Array<BackdropFilter>, checkEmptyBounds: boolean = true) {\r\n    const renderer = this.renderer;\r\n    const filterStack = this.defaultFilterStack;\r\n    const state = this.statePool.pop() || new FilterState();\r\n    const renderTextureSystem = this.renderer.renderTexture;\r\n\r\n    let resolution = filters[0].resolution;\r\n    let padding = filters[0].padding;\r\n    let autoFit = filters[0].autoFit;\r\n    let legacy = filters[0].legacy;\r\n\r\n    for (let i = 1; i < filters.length; i++)\r\n    {\r\n        const filter = filters[i];\r\n\r\n        resolution = Math.min(resolution, filter.resolution);\r\n        padding = this.useMaxPadding\r\n            ? Math.max(padding, filter.padding)\r\n            : padding + filter.padding;\r\n        autoFit = autoFit && filter.autoFit;\r\n\r\n        legacy = legacy || filter.legacy;\r\n    }\r\n\r\n    if (filterStack.length === 1)\r\n    {\r\n        this.defaultFilterStack[0].renderTexture = renderTextureSystem.current;\r\n    }\r\n\r\n    filterStack.push(state);\r\n\r\n    state.resolution = resolution;\r\n\r\n    state.legacy = legacy;\r\n\r\n    state.target = target;\r\n    state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));\r\n\r\n    state.sourceFrame.pad(padding);\r\n\r\n    let canUseBackdrop = true;\r\n    if (autoFit)\r\n    {\r\n        const sourceFrameProjected = (this as any).tempRect.copyFrom(renderTextureSystem.sourceFrame);\r\n\r\n        // Project source frame into world space (if projection is applied)\r\n        if (renderer.projection.transform)\r\n        {\r\n            (this as any).transformAABB(\r\n                tempMatrix.copyFrom(renderer.projection.transform).invert(),\r\n                sourceFrameProjected\r\n            );\r\n        }\r\n\r\n        state.sourceFrame.fit(sourceFrameProjected);\r\n    } else {\r\n        //check if backdrop is obtainable after rejecting autoFit\r\n        canUseBackdrop = containsRect(this.renderer.renderTexture.sourceFrame, state.sourceFrame);\r\n    }\r\n\r\n    if (checkEmptyBounds && state.sourceFrame.width <= 1 && state.sourceFrame.height <= 1) {\r\n        filterStack.pop();\r\n        state.clear();\r\n        this.statePool.push(state);\r\n        return false;\r\n    }\r\n    (this as any).roundFrame(\r\n        state.sourceFrame,\r\n        renderTextureSystem.current ? renderTextureSystem.current.resolution : renderer.resolution,\r\n        renderTextureSystem.sourceFrame,\r\n        renderTextureSystem.destinationFrame,\r\n        renderer.projection.transform,\r\n    );\r\n\r\n    // round to whole number based on resolution\r\n    state.sourceFrame.ceil(resolution);\r\n\r\n    // detect backdrop uniform\r\n    if (canUseBackdrop) {\r\n        let backdrop = null;\r\n        for (let i = 0; i < filters.length; i++) {\r\n            const bName = filters[i].backdropUniformName;\r\n            if (bName) {\r\n                if (backdrop === null) {\r\n                    backdrop = this.prepareBackdrop(state.sourceFrame);\r\n                }\r\n\r\n                filters[i].uniforms[bName] = backdrop;\r\n                if (backdrop) {\r\n                    filters[i]._backdropActive = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution);\r\n    state.filters = filters;\r\n\r\n    state.destinationFrame.width = state.renderTexture.width;\r\n    state.destinationFrame.height = state.renderTexture.height;\r\n\r\n    const destinationFrame = (this as any).tempRect;\r\n\r\n    destinationFrame.x = 0;\r\n    destinationFrame.y = 0;\r\n    destinationFrame.width = state.sourceFrame.width;\r\n    destinationFrame.height = state.sourceFrame.height;\r\n\r\n    state.renderTexture.filterFrame = state.sourceFrame;\r\n    state.bindingSourceFrame.copyFrom(renderTextureSystem.sourceFrame);\r\n    state.bindingDestinationFrame.copyFrom(renderTextureSystem.destinationFrame);\r\n\r\n    state.transform = renderer.projection.transform;\r\n    renderer.projection.transform = null;\r\n    renderTextureSystem.bind(state.renderTexture, state.sourceFrame, destinationFrame);\r\n\r\n    const cc = filters[filters.length - 1].clearColor as any;\r\n\r\n    if (cc) {\r\n        // take clear color from filter, it helps for advanced DisplacementFilter\r\n        renderer.framebuffer.clear(cc[0], cc[1], cc[2], cc[3]);\r\n    } else {\r\n        renderer.framebuffer.clear(0, 0, 0, 0);\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nfunction push(this: IPictureFilterSystem,\r\n              target: DisplayObject, filters: Array<Filter>) {\r\n    return this.pushWithCheck(target, filters, false);\r\n}\r\n\r\nfunction pop(this: IPictureFilterSystem) {\r\n    const filterStack = this.defaultFilterStack;\r\n    const state = filterStack.pop();\r\n    const filters = state.filters as Array<BackdropFilter>;\r\n\r\n    this.activeState = state;\r\n\r\n    const globalUniforms = this.globalUniforms.uniforms;\r\n\r\n    globalUniforms.outputFrame = state.sourceFrame;\r\n    globalUniforms.resolution = state.resolution;\r\n\r\n    const inputSize = globalUniforms.inputSize;\r\n    const inputPixel = globalUniforms.inputPixel;\r\n    const inputClamp = globalUniforms.inputClamp;\r\n\r\n    inputSize[0] = state.destinationFrame.width;\r\n    inputSize[1] = state.destinationFrame.height;\r\n    inputSize[2] = 1.0 / inputSize[0];\r\n    inputSize[3] = 1.0 / inputSize[1];\r\n\r\n    inputPixel[0] = inputSize[0] * state.resolution;\r\n    inputPixel[1] = inputSize[1] * state.resolution;\r\n    inputPixel[2] = 1.0 / inputPixel[0];\r\n    inputPixel[3] = 1.0 / inputPixel[1];\r\n\r\n    inputClamp[0] = 0.5 * inputPixel[2];\r\n    inputClamp[1] = 0.5 * inputPixel[3];\r\n    inputClamp[2] = (state.sourceFrame.width * inputSize[2]) - (0.5 * inputPixel[2]);\r\n    inputClamp[3] = (state.sourceFrame.height * inputSize[3]) - (0.5 * inputPixel[3]);\r\n\r\n    // only update the rect if its legacy..\r\n    if (state.legacy)\r\n    {\r\n        const filterArea = globalUniforms.filterArea;\r\n\r\n        filterArea[0] = state.destinationFrame.width;\r\n        filterArea[1] = state.destinationFrame.height;\r\n        filterArea[2] = state.sourceFrame.x;\r\n        filterArea[3] = state.sourceFrame.y;\r\n\r\n        globalUniforms.filterClamp = globalUniforms.inputClamp;\r\n    }\r\n\r\n    this.globalUniforms.update();\r\n\r\n    const lastState = filterStack[filterStack.length - 1];\r\n\r\n    if (state.renderTexture.framebuffer.multisample > 1)\r\n    {\r\n        this.renderer.framebuffer.blit();\r\n    }\r\n\r\n    if (filters.length === 1)\r\n    {\r\n        filters[0].apply(this, state.renderTexture, lastState.renderTexture, CLEAR_MODES.BLEND, state);\r\n\r\n        this.returnFilterTexture(state.renderTexture);\r\n    }\r\n    else\r\n    {\r\n        let flip = state.renderTexture;\r\n        let flop = this.getOptimalFilterTexture(\r\n            flip.width,\r\n            flip.height,\r\n            state.resolution\r\n        );\r\n\r\n        flop.filterFrame = flip.filterFrame;\r\n\r\n        let i = 0;\r\n\r\n        for (i = 0; i < filters.length - 1; ++i)\r\n        {\r\n            filters[i].apply(this, flip, flop, CLEAR_MODES.CLEAR, state);\r\n\r\n            const t = flip;\r\n\r\n            flip = flop;\r\n            flop = t;\r\n        }\r\n\r\n        filters[i].apply(this, flip, lastState.renderTexture, CLEAR_MODES.BLEND, state);\r\n\r\n        this.returnFilterTexture(flip);\r\n        this.returnFilterTexture(flop);\r\n    }\r\n\r\n    // release the backdrop!\r\n    let backdropFree = false;\r\n\r\n    for (let i = 0; i < filters.length; i++) {\r\n        if (filters[i]._backdropActive) {\r\n            const bName = filters[i].backdropUniformName;\r\n            if (!backdropFree) {\r\n                this.returnFilterTexture(filters[i].uniforms[bName]);\r\n                backdropFree = true;\r\n            }\r\n            filters[i].uniforms[bName] = null;\r\n            filters[i]._backdropActive = false;\r\n        }\r\n    }\r\n\r\n    state.clear();\r\n    this.statePool.push(state);\r\n}\r\n\r\nlet hadBackbufferError = false;\r\n\r\n/**\r\n * Takes a part of current render target corresponding to bounds\r\n * fits sourceFrame to current render target frame to evade problems\r\n */\r\nfunction prepareBackdrop(bounds: Rectangle): RenderTexture {\r\n    const renderer = this.renderer;\r\n    const renderTarget = renderer.renderTexture.current;\r\n    const fr = this.renderer.renderTexture.sourceFrame;\r\n\r\n    //TODO: take destinationFrame into account, all according to ShukantPal refactoring\r\n\r\n    if (!renderTarget) {\r\n        if (!hadBackbufferError) {\r\n            hadBackbufferError = true;\r\n            console.warn('pixi-picture: you are trying to use Blend Filter on main framebuffer! That wont work.');\r\n        }\r\n        return null;\r\n    }\r\n\r\n    const resolution = renderTarget.baseTexture.resolution;\r\n\r\n    //bounds.fit(fr);\r\n\r\n    const x = (bounds.x - fr.x) * resolution;\r\n    const y = (bounds.y - fr.y) * resolution;\r\n    const w = (bounds.width) * resolution;\r\n    const h = (bounds.height) * resolution;\r\n\r\n    const gl = renderer.gl;\r\n    const rt = this.getOptimalFilterTexture(w, h, 1);\r\n\r\n    rt.filterFrame = fr;\r\n    renderer.texture.bindForceLocation(rt.baseTexture, 0);\r\n    gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x, y, w, h);\r\n\r\n    return rt;\r\n}\r\n\r\nexport function applyMixins() {\r\n    (TextureSystem as any).prototype.bindForceLocation = bindForceLocation;\r\n    (FilterSystem as any).prototype.push = push;\r\n    (FilterSystem as any).prototype.pushWithCheck = pushWithCheck as any;\r\n    (FilterSystem as any).prototype.pop = pop;\r\n    (FilterSystem as any).prototype.prepareBackdrop = prepareBackdrop;\r\n}\r\n","export * from './BlendFilter';\r\nexport * from './MaskFilter';\r\nexport * from './ShaderParts';\r\nexport * from './Sprite';\r\nexport * from './TilingSprite';\r\nimport {IPictureFilterSystem, IPictureTextureSystem, applyMixins} from \"./FilterSystemMixin\";\r\nexport {IPictureFilterSystem, IPictureTextureSystem, applyMixins};\r\n\r\napplyMixins();\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;GAcA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GCVA;;;;;GAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GCyHA;GACA;GACA;GACA;GAEA;GACA;;;;;;;;;GAUA;;;;;;;;;GAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GC5IA;;;;;;;;;;;;;GAaA;GAEA;;;;;;;GAQA;GAEA;GAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA+HA;GAEA;;GAGA;GAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAyGA;GAEA;GAMA;;;;;;;;;;;;;;;;;;;;;;GAgCA;;;;;;;GAQA;;GClUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}